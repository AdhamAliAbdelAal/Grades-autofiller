number_of_questions=len(pre_question_cnts)/number_of_choices
if(len(pre_question_cnts)):
    qs=0
    # Get student answers
    answers=[]

    # Iterate over each row
    for (_,i) in enumerate(np.arange(0,len(question_cnts),number_of_columns*number_of_choices)):
        
        # detect number of contours in row
        number_of_conts=detect_number_of_contours(question_cnts[i:i+number_of_columns*number_of_choices])
        print(number_of_conts)

        # Get all bubbles of the current row which has (number_of_columns) questions
        curr_row_cnts_left,_=imcnts.sort_contours(question_cnts[i:i+number_of_conts]) if number_of_conts>0 else ([],'')
        curr_row_cnts_right,_=imcnts.sort_contours(question_cnts[i+number_of_conts:i+number_of_conts+number_of_columns*number_of_choices])
        print(curr_row_cnts_left,curr_row_cnts_right)
        curr_row_cnts=curr_row_cnts_left[0]+curr_row_cnts_right
        
        # Iterate over each question
        for k in np.arange(0,len(curr_row_cnts),number_of_choices):

            # Current Question answers
            curr_ques_cnts=curr_row_cnts[k:k+number_of_choices]
            color1=colors[qs%len(colors)]
            qs=qs+1
            cv2.drawContours(temp,curr_ques_cnts,-1,color1, 5)

            bubbled=None

            for (j,c) in enumerate(curr_ques_cnts):

                # Get the maximum shaded bubble
                mask = np.zeros(thresholded.shape, dtype="uint8")
                cv2.drawContours(mask, [c], -1, 255, -1)
                mask= cv2.bitwise_and(thresholded, mask)
                total= cv2.countNonZero(mask)

                if bubbled is None or total > bubbled[0]:
                    bubbled= (total, j)

            answers.append(chr(bubbled[1]+ord('A')))
    print(answers,len(answers))
    